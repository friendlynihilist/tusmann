{"version":3,"file":"regionize.min.js","sources":["../src/Region.js","../src/nodeTypes.js","../src/schedule.js","../src/ignoreOverflow.js","../src/addTextNode.js","../src/tryInNextRegion.js","../src/clonePath.js","../src/ensureImageLoaded.js","../src/orderedListRule.js","../src/tableRowRule.js","../src/flowIntoRegions.js"],"sourcesContent":["const div = (cls) => {\n  const el = document.createElement('div');\n  el.classList.add(cls);\n  return el;\n};\n\nclass Region {\n  constructor(elmt) {\n    this.element = elmt;\n    this.content = div('region-content');\n    this.content.style.padding = '0.1px';\n    this.content.style.position = 'relative';\n    this.element.appendChild(this.content);\n    this.path = [];\n  }\n\n  setPath(newPath) {\n    this.path = newPath;\n    if (newPath.length > 0) this.content.appendChild(newPath[0]);\n  }\n\n  get currentElement() {\n    const len = this.path.length;\n    if (len > 0) return this.path[len - 1];\n    return this.content;\n  }\n\n  get isEmpty() {\n    return this.content.textContent.trim() === '' && this.content.offsetHeight < 1;\n  }\n\n  get isReasonableSize() {\n    const box = this.element.getBoundingClientRect();\n    return (box.height > 100) && (box.width > 100); // TODO: Number is arbitrary\n  }\n\n  overflowAmount() {\n    const contentH = this.content.offsetHeight;\n    const boxH = this.element.offsetHeight;\n    if (boxH === 0) throw Error('Regionizer: Trying to flow into an element with zero height.');\n    return contentH - boxH;\n  }\n\n  hasOverflowed() {\n    return this.overflowAmount() > -5;\n  }\n}\n\nexport default Region;\n","const isTextNode = node => node.nodeType === Node.TEXT_NODE;\nconst isElement = node => node.nodeType === Node.ELEMENT_NODE;\nconst isScript = node => node.tagName === 'SCRIPT';\nconst isImage = node => node.tagName === 'IMG';\nconst isUnloadedImage = node => isImage(node) && !node.naturalWidth;\nconst isContentElement = node => isElement(node) && !isScript(node);\n\nexport { isTextNode, isElement, isContentElement, isUnloadedImage };\n","const MAX_TIME = 30; // ms\n\nconst rAF = () => new Promise((resolve) => {\n  requestAnimationFrame(t => resolve(t));\n});\n\nlet lastYieldTime = 0;\n\nconst shouldYield = () => {\n  const timeSinceYield = performance.now() - lastYieldTime;\n  return timeSinceYield > MAX_TIME;\n};\n\nconst yieldIfNecessary = async () => {\n  if (shouldYield()) lastYieldTime = await rAF();\n};\n\nexport { shouldYield, yieldIfNecessary };\n","const overflowAttr = 'data-ignore-overflow';\n// Walk up the tree to see if we are within\n// an overflow-ignoring node\nconst ignoreOverflow = (element) => {\n  if (element.hasAttribute(overflowAttr)) return true;\n  if (element.parentElement) return ignoreOverflow(element.parentElement);\n  return false;\n};\n\nexport default ignoreOverflow;\n","import { yieldIfNecessary } from './schedule';\nimport ignoreOverflow from './ignoreOverflow';\nimport { isTextNode } from './nodeTypes';\n\nconst createTextNode = (document.createTextNode).bind(document);\n\n// Try adding a text node in one go.\n// Returns true if all the text fits, false if none fits.\nconst addTextNode = async (textNode, parent, hasOverflowed) => {\n  parent.appendChild(textNode);\n  const success = !hasOverflowed();\n  if (!success) parent.removeChild(textNode);\n  await yieldIfNecessary();\n  return success;\n};\n\n\n// Try adding a text node by incrementally adding words\n// until it just barely doesnt overflow.\n//\n// Returns true if all the text fits, false if none fits,\n// or new textnode containing the remainder text.\nconst addTextNodeUntilOverflow = async (textNode, parent, hasOverflowed) => {\n  const originalText = textNode.nodeValue;\n  parent.appendChild(textNode);\n\n  if (!hasOverflowed() || ignoreOverflow(parent)) {\n    return true;\n  }\n\n  // Add letter by letter until overflow\n  let pos = 0;\n  textNode.nodeValue = originalText.substr(0, pos);\n\n  while (!hasOverflowed() && pos < originalText.length) {\n    // advance to next non-space character\n    pos += 1;\n    while (pos < originalText.length && originalText.charAt(pos) !== ' ') pos += 1;\n\n    if (pos < originalText.length) {\n      // reveal more text\n      textNode.nodeValue = originalText.substr(0, pos);\n      await yieldIfNecessary();\n    }\n  }\n\n  // Back out to word boundary\n  if (originalText.charAt(pos) === ' ') pos -= 1; // TODO: redundant\n  while (originalText.charAt(pos) !== ' ' && pos > 0) pos -= 1;\n\n  if (pos < 1) {\n    // We didn't even add a complete word, don't add node\n    textNode.nodeValue = originalText;\n    parent.removeChild(textNode);\n    return false; // TODO\n  }\n\n  // trim text to word\n  const fittingText = originalText.substr(0, pos);\n  const overflowingText = originalText.substr(pos);\n  textNode.nodeValue = fittingText;\n\n  // Create a new text node for the next flow box\n  const remainingTextNode = createTextNode(overflowingText);\n  return remainingTextNode;\n};\n\n\n// Fills text across multiple elements by requesting a continuation\n// once the current element overflows\nconst addTextNodeAcrossParents = async (textNode, parent, nextParent, hasOverflowed) => {\n  const result = await addTextNodeUntilOverflow(textNode, parent, hasOverflowed);\n  if (isTextNode(result)) {\n    const nextElement = nextParent();\n    return addTextNodeAcrossParents(result, nextElement, nextParent, hasOverflowed);\n  }\n  return result;\n};\n\nexport { addTextNode, addTextNodeUntilOverflow, addTextNodeAcrossParents };\n","// Shifts this element to the next page. If any of its\n// ancestors cannot be split across page, it will\n// step up the tree to find the first ancestor\n// that can be split, and move all of that descendants\n// to the next page.\nconst tryInNextRegion = (region, makeNextRegion, canSplit) => {\n  if (region.path.length <= 1) {\n    throw Error('Regionize: Attempting to move the top-level element');\n  }\n  const startLength = region.path.length;\n\n  // So this node won't get cloned. TODO: this is unclear\n  const elementToMove = region.path.pop();\n\n  // find the nearest splittable parent\n  let nearestElementThatCanBeMoved = elementToMove;\n  const pathToRestore = [];\n  while (region.path.length > 1 && !canSplit(region.currentElement)) {\n    nearestElementThatCanBeMoved = region.path.pop();\n    pathToRestore.unshift(nearestElementThatCanBeMoved);\n  }\n\n  // Once a node is moved to a new page, it should no longer trigger another\n  // move. otherwise tall elements will endlessly get shifted to the next page\n  nearestElementThatCanBeMoved.setAttribute('data-bindery-did-move', true);\n\n  const parent = nearestElementThatCanBeMoved.parentNode;\n  parent.removeChild(nearestElementThatCanBeMoved);\n\n  // If the nearest ancestor would be empty without this node,\n  // move it to the next page too.\n  if (region.path.length > 1 && region.currentElement.textContent.trim() === '') {\n    parent.appendChild(nearestElementThatCanBeMoved);\n    nearestElementThatCanBeMoved = region.path.pop();\n    pathToRestore.unshift(nearestElementThatCanBeMoved);\n    nearestElementThatCanBeMoved.parentNode.removeChild(nearestElementThatCanBeMoved);\n  }\n\n  let nextRegion;\n  if (!region.isEmpty) {\n    if (region.hasOverflowed()) {\n      // Recovery failed, maybe the box contains a large\n      // unsplittable element.\n      region.suppressErrors = true;\n    }\n    nextRegion = makeNextRegion();\n  } else {\n    // If the page is empty when this node is removed,\n    // then it won't help to move it to the next page.\n    // Instead continue here until the node is done.\n    nextRegion = region;\n  }\n\n  // append moved node as first in new page\n  nextRegion.currentElement.appendChild(nearestElementThatCanBeMoved);\n\n  // restore subpath\n  pathToRestore.forEach(r => nextRegion.path.push(r));\n  nextRegion.path.push(elementToMove);\n\n  if (startLength !== nextRegion.path.length) {\n    throw Error('Regionize: Restored path depth does not match original path depth');\n  }\n};\n\nexport default tryInNextRegion;\n","// The path is an array of nested elments,\n// for example .content > article > p > a).\n//\n// It's shallowly cloned every time we move to the next page,\n// to create the illusion that nodes are continuing from page\n// to page.\n//\n// The transition can be customized by setting a Split rule,\n// which lets you add classes to the original and cloned element\n// to customize styling.\n\nconst clonePath = (oldPath, applyRules) => {\n  const newPath = [];\n\n  const deepClone = (el) => {\n    const clone = el.cloneNode(true); // deep clone, could be th > h3 > span;\n    applyRules(el, clone);\n    return clone;\n  };\n\n  for (let i = oldPath.length - 1; i >= 0; i -= 1) {\n    const original = oldPath[i];\n    const clone = original.cloneNode(false); // shallow\n    const nextChild = oldPath[i + 1];\n    clone.innerHTML = '';\n\n    applyRules(original, clone, nextChild, deepClone);\n\n    if (i < oldPath.length - 1) clone.appendChild(newPath[i + 1]);\n    newPath[i] = clone;\n  }\n\n  return newPath;\n};\n\nexport default clonePath;\n","// Polls every 10ms for image.naturalWidth\n// or an error event.\n//\n// Note: Doesn't ever reject, since missing images\n// shouldn't prevent layout from resolving\n\nconst wait10 = () => new Promise((resolve) => {\n  setTimeout(() => { resolve(); }, 10);\n});\n\nconst ensureImageLoaded = async (image) => {\n  const imgStart = performance.now();\n  let failed = false;\n  image.addEventListener('error', () => { failed = true; });\n  image.src = image.src; // re-trigger error if already failed\n\n  while (!image.naturalWidth && !failed) {\n    await wait10();\n  }\n\n  return performance.now() - imgStart;\n};\n\nexport default ensureImageLoaded;\n","const preserveNumbering = (original, clone, nextChild) => {\n  // restart numbering\n  let prevStart = 1;\n  if (original.hasAttribute('start')) {\n    // the OL is also a continuation\n    prevStart = parseInt(original.getAttribute('start'), 10);\n  }\n  if (nextChild && nextChild.tagName === 'LI') {\n    // the first list item is a continuation\n    prevStart -= 1;\n  }\n  const prevCount = original.children.length;\n  const newStart = prevStart + prevCount;\n  clone.setAttribute('start', newStart);\n};\n\nexport default preserveNumbering;\n","const preserveTableColumns = (original, clone, nextChild, deepClone) => {\n  const columns = [...original.children];\n\n  const currentIndex = columns.indexOf(nextChild);\n  for (let i = 0; i < currentIndex; i += 1) {\n    const clonedCol = deepClone(columns[i]);\n    clone.appendChild(clonedCol);\n  }\n};\n\nexport default preserveTableColumns;\n","import { isTextNode, isUnloadedImage, isContentElement } from './nodeTypes';\nimport { addTextNode, addTextNodeAcrossParents } from './addTextNode';\nimport tryInNextRegion from './tryInNextRegion';\nimport ignoreOverflow from './ignoreOverflow';\nimport clonePath from './clonePath';\nimport ensureImageLoaded from './ensureImageLoaded';\nimport orderedListRule from './orderedListRule';\nimport tableRowRule from './tableRowRule';\n\nconst noop = () => {};\nconst always = () => true;\nconst never = () => false;\n\n// flow content through FlowBoxes.\n// This function is not book-specific,\n// the caller is responsible for managing\n// and creating boxes.\nconst flowIntoRegions = async (opts) => {\n  // required options\n  const content = opts.content;\n  const createRegion = opts.createRegion;\n  if (!content) throw Error('content not specified');\n  if (!createRegion) throw Error('createRegion not specified');\n\n  // optional\n  const applySplit = opts.applySplit || noop;\n  const canSplit = opts.canSplit || always;\n  const beforeAdd = opts.beforeAdd || noop;\n  const afterAdd = opts.afterAdd || noop;\n  const didWaitFor = opts.didWaitFor || noop;\n  const shouldTraverse = opts.shouldTraverse || never;\n\n  // ____\n  // Begin\n  let currentRegion = createRegion();\n  const hasOverflowed = () => currentRegion.hasOverflowed();\n  const canSplitCurrent = () => canSplit(currentRegion.currentElement);\n  const ignoreCurrentOverflow = () => ignoreOverflow(currentRegion.currentElement);\n\n  const splitRules = (prev, clone, next, deepClone) => {\n    if (prev.tagName === 'OL') orderedListRule(prev, clone, next, deepClone);\n    if (prev.tagName === 'TR') tableRowRule(prev, clone, next, deepClone);\n    applySplit(prev, clone, next, deepClone);\n  };\n\n  const continueInNextRegion = () => {\n    const oldBox = currentRegion;\n    currentRegion = createRegion();\n\n    const newPath = clonePath(oldBox.path, splitRules);\n    currentRegion.setPath(newPath);\n    return currentRegion;\n  };\n\n  const continuedParent = () => {\n    continueInNextRegion();\n    return currentRegion.currentElement;\n  };\n\n  const addTextWithoutChecks = (textNode, parent) => {\n    parent.appendChild(textNode);\n    if (!ignoreCurrentOverflow() && canSplitCurrent()) {\n      currentRegion.suppressErrors = true;\n      continueInNextRegion();\n    }\n  };\n\n  const addSplittableTextNode = async (textNode) => {\n    const el = currentRegion.currentElement;\n    let hasAdded = await addTextNodeAcrossParents(textNode, el, continuedParent, hasOverflowed);\n    if (!hasAdded && currentRegion.path.length > 1) {\n      // retry 1\n      tryInNextRegion(currentRegion, continueInNextRegion, canSplit);\n      hasAdded = await addTextNodeAcrossParents(textNode, el, continuedParent, hasOverflowed);\n    }\n    if (!hasAdded) {\n      // retry 2\n      addTextWithoutChecks(textNode, currentRegion.currentElement);\n    }\n  };\n\n  const addWholeTextNode = async (textNode) => {\n    let hasAdded = await addTextNode(textNode, currentRegion.currentElement, hasOverflowed);\n    if (!hasAdded && !ignoreCurrentOverflow()) {\n      // retry 1\n      tryInNextRegion(currentRegion, continueInNextRegion, canSplit);\n      hasAdded = await addTextNode(textNode, currentRegion.currentElement, hasOverflowed);\n    }\n    if (!hasAdded) {\n      // retry 2\n      addTextWithoutChecks(textNode, currentRegion.currentElement);\n    }\n  };\n\n  // No need to traverse every node if fifts AND\n  // none of the contents could change size.\n  // Images and custom rules could cause the size to change\n  const canSkipTraversal = (element) => {\n    const containsImage = element.querySelector('img');\n    return !containsImage && !shouldTraverse(element);\n  };\n\n  let safeAddElementNode;\n\n  // Adds an element node by clearing its childNodes, then inserting them\n  // one by one recursively until they overflow the region\n  const addElementNode = async (element) => {\n    // Insert element\n    currentRegion.currentElement.appendChild(element);\n    currentRegion.path.push(element);\n\n    if (canSkipTraversal(element)) {\n      // console.log('maybe short circuit');\n      if (!hasOverflowed()) {\n        // console.log('did short circuit');\n        return currentRegion.path.pop();\n      }\n    }\n\n    // Clear element\n    const childNodes = [...element.childNodes];\n    element.innerHTML = '';\n\n    // Overflows when empty\n    if (hasOverflowed() && !ignoreCurrentOverflow() && canSplitCurrent()) {\n      tryInNextRegion(currentRegion, continueInNextRegion, canSplit);\n    }\n\n    const shouldSplit = canSplit(element) && !ignoreOverflow(element);\n\n    for (const child of childNodes) {\n      if (isTextNode(child)) {\n        await (shouldSplit ? addSplittableTextNode : addWholeTextNode)(child);\n      } else if (isContentElement(child)) {\n        await safeAddElementNode(child);\n      } else {\n        // Skip comments and unknown nodes\n      }\n    }\n    return currentRegion.path.pop();\n  };\n\n  safeAddElementNode = async (element) => {\n    // Ensure images are loaded before measuring\n    if (isUnloadedImage(element)) {\n      const waitTime = await ensureImageLoaded(element);\n      didWaitFor(waitTime);\n    }\n\n    // Transforms before adding\n    beforeAdd(element, continueInNextRegion);\n\n    const addedElement = await addElementNode(element);\n\n    // Transforms after adding\n    afterAdd(addedElement, continueInNextRegion);\n  };\n\n  return safeAddElementNode(content);\n};\n\nexport default flowIntoRegions;\n"],"names":["div","cls","el","document","createElement","classList","add","Region","constructor","elmt","element","content","style","padding","position","appendChild","path","setPath","newPath","length","currentElement","len","isEmpty","textContent","trim","offsetHeight","isReasonableSize","box","getBoundingClientRect","height","width","overflowAmount","contentH","boxH","Error","hasOverflowed","isTextNode","node","nodeType","Node","TEXT_NODE","isElement","ELEMENT_NODE","isScript","tagName","isImage","isUnloadedImage","naturalWidth","isContentElement","rAF","Promise","resolve","requestAnimationFrame","t","lastYieldTime","shouldYield","timeSinceYield","performance","now","yieldIfNecessary","ignoreOverflow","hasAttribute","parentElement","createTextNode","bind","addTextNode","textNode","parent","success","removeChild","addTextNodeUntilOverflow","originalText","nodeValue","pos","substr","charAt","fittingText","overflowingText","remainingTextNode","addTextNodeAcrossParents","nextParent","result","nextElement","tryInNextRegion","region","makeNextRegion","canSplit","startLength","elementToMove","pop","nearestElementThatCanBeMoved","pathToRestore","unshift","setAttribute","parentNode","nextRegion","suppressErrors","forEach","r","push","clonePath","oldPath","applyRules","deepClone","clone","cloneNode","i","original","nextChild","innerHTML","wait10","setTimeout","ensureImageLoaded","image","imgStart","failed","addEventListener","src","preserveNumbering","prevStart","parseInt","getAttribute","prevCount","children","newStart","preserveTableColumns","columns","currentIndex","indexOf","clonedCol","noop","always","never","opts","createRegion","applySplit","beforeAdd","afterAdd","didWaitFor","shouldTraverse","currentRegion","canSplitCurrent","ignoreCurrentOverflow","splitRules","prev","next","orderedListRule","tableRowRule","continueInNextRegion","oldBox","continuedParent","addTextWithoutChecks","addSplittableTextNode","hasAdded","addWholeTextNode","canSkipTraversal","containsImage","querySelector","safeAddElementNode","addElementNode","childNodes","shouldSplit","child","waitTime","addedElement"],"mappings":"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"}