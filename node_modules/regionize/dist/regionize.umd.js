/* ðŸ“– Regionize v0.1.3 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.Regionize = {})));
}(this, (function (exports) { 'use strict';

  const div = (cls) => {
    const el = document.createElement('div');
    el.classList.add(cls);
    return el;
  };

  class Region {
    constructor(elmt) {
      this.element = elmt;
      this.content = div('region-content');
      this.content.style.padding = '0.1px';
      this.content.style.position = 'relative';
      this.element.appendChild(this.content);
      this.path = [];
    }

    setPath(newPath) {
      this.path = newPath;
      if (newPath.length > 0) this.content.appendChild(newPath[0]);
    }

    get currentElement() {
      const len = this.path.length;
      if (len > 0) return this.path[len - 1];
      return this.content;
    }

    get isEmpty() {
      return this.content.textContent.trim() === '' && this.content.offsetHeight < 1;
    }

    get isReasonableSize() {
      const box = this.element.getBoundingClientRect();
      return (box.height > 100) && (box.width > 100); // TODO: Number is arbitrary
    }

    overflowAmount() {
      const contentH = this.content.offsetHeight;
      const boxH = this.element.offsetHeight;
      if (boxH === 0) throw Error('Regionizer: Trying to flow into an element with zero height.');
      return contentH - boxH;
    }

    hasOverflowed() {
      return this.overflowAmount() > -5;
    }
  }

  const isTextNode = node => node.nodeType === Node.TEXT_NODE;
  const isElement = node => node.nodeType === Node.ELEMENT_NODE;
  const isScript = node => node.tagName === 'SCRIPT';
  const isImage = node => node.tagName === 'IMG';
  const isUnloadedImage = node => isImage(node) && !node.naturalWidth;
  const isContentElement = node => isElement(node) && !isScript(node);

  const MAX_TIME = 30; // ms

  const rAF = () => new Promise((resolve) => {
    requestAnimationFrame(t => resolve(t));
  });

  let lastYieldTime = 0;

  const shouldYield = () => {
    const timeSinceYield = performance.now() - lastYieldTime;
    return timeSinceYield > MAX_TIME;
  };

  const yieldIfNecessary = async () => {
    if (shouldYield()) lastYieldTime = await rAF();
  };

  const overflowAttr = 'data-ignore-overflow';
  // Walk up the tree to see if we are within
  // an overflow-ignoring node
  const ignoreOverflow = (element) => {
    if (element.hasAttribute(overflowAttr)) return true;
    if (element.parentElement) return ignoreOverflow(element.parentElement);
    return false;
  };

  const createTextNode = (document.createTextNode).bind(document);

  // Try adding a text node in one go.
  // Returns true if all the text fits, false if none fits.
  const addTextNode = async (textNode, parent, hasOverflowed) => {
    parent.appendChild(textNode);
    const success = !hasOverflowed();
    if (!success) parent.removeChild(textNode);
    await yieldIfNecessary();
    return success;
  };


  // Try adding a text node by incrementally adding words
  // until it just barely doesnt overflow.
  //
  // Returns true if all the text fits, false if none fits,
  // or new textnode containing the remainder text.
  const addTextNodeUntilOverflow = async (textNode, parent, hasOverflowed) => {
    const originalText = textNode.nodeValue;
    parent.appendChild(textNode);

    if (!hasOverflowed() || ignoreOverflow(parent)) {
      return true;
    }

    // Add letter by letter until overflow
    let pos = 0;
    textNode.nodeValue = originalText.substr(0, pos);

    while (!hasOverflowed() && pos < originalText.length) {
      // advance to next non-space character
      pos += 1;
      while (pos < originalText.length && originalText.charAt(pos) !== ' ') pos += 1;

      if (pos < originalText.length) {
        // reveal more text
        textNode.nodeValue = originalText.substr(0, pos);
        await yieldIfNecessary();
      }
    }

    // Back out to word boundary
    if (originalText.charAt(pos) === ' ') pos -= 1; // TODO: redundant
    while (originalText.charAt(pos) !== ' ' && pos > 0) pos -= 1;

    if (pos < 1) {
      // We didn't even add a complete word, don't add node
      textNode.nodeValue = originalText;
      parent.removeChild(textNode);
      return false; // TODO
    }

    // trim text to word
    const fittingText = originalText.substr(0, pos);
    const overflowingText = originalText.substr(pos);
    textNode.nodeValue = fittingText;

    // Create a new text node for the next flow box
    const remainingTextNode = createTextNode(overflowingText);
    return remainingTextNode;
  };


  // Fills text across multiple elements by requesting a continuation
  // once the current element overflows
  const addTextNodeAcrossParents = async (textNode, parent, nextParent, hasOverflowed) => {
    const result = await addTextNodeUntilOverflow(textNode, parent, hasOverflowed);
    if (isTextNode(result)) {
      const nextElement = nextParent();
      return addTextNodeAcrossParents(result, nextElement, nextParent, hasOverflowed);
    }
    return result;
  };

  // Shifts this element to the next page. If any of its
  // ancestors cannot be split across page, it will
  // step up the tree to find the first ancestor
  // that can be split, and move all of that descendants
  // to the next page.
  const tryInNextRegion = (region, makeNextRegion, canSplit) => {
    if (region.path.length <= 1) {
      throw Error('Regionize: Attempting to move the top-level element');
    }
    const startLength = region.path.length;

    // So this node won't get cloned. TODO: this is unclear
    const elementToMove = region.path.pop();

    // find the nearest splittable parent
    let nearestElementThatCanBeMoved = elementToMove;
    const pathToRestore = [];
    while (region.path.length > 1 && !canSplit(region.currentElement)) {
      nearestElementThatCanBeMoved = region.path.pop();
      pathToRestore.unshift(nearestElementThatCanBeMoved);
    }

    // Once a node is moved to a new page, it should no longer trigger another
    // move. otherwise tall elements will endlessly get shifted to the next page
    nearestElementThatCanBeMoved.setAttribute('data-bindery-did-move', true);

    const parent = nearestElementThatCanBeMoved.parentNode;
    parent.removeChild(nearestElementThatCanBeMoved);

    // If the nearest ancestor would be empty without this node,
    // move it to the next page too.
    if (region.path.length > 1 && region.currentElement.textContent.trim() === '') {
      parent.appendChild(nearestElementThatCanBeMoved);
      nearestElementThatCanBeMoved = region.path.pop();
      pathToRestore.unshift(nearestElementThatCanBeMoved);
      nearestElementThatCanBeMoved.parentNode.removeChild(nearestElementThatCanBeMoved);
    }

    let nextRegion;
    if (!region.isEmpty) {
      if (region.hasOverflowed()) {
        // Recovery failed, maybe the box contains a large
        // unsplittable element.
        region.suppressErrors = true;
      }
      nextRegion = makeNextRegion();
    } else {
      // If the page is empty when this node is removed,
      // then it won't help to move it to the next page.
      // Instead continue here until the node is done.
      nextRegion = region;
    }

    // append moved node as first in new page
    nextRegion.currentElement.appendChild(nearestElementThatCanBeMoved);

    // restore subpath
    pathToRestore.forEach(r => nextRegion.path.push(r));
    nextRegion.path.push(elementToMove);

    if (startLength !== nextRegion.path.length) {
      throw Error('Regionize: Restored path depth does not match original path depth');
    }
  };

  // The path is an array of nested elments,
  // for example .content > article > p > a).
  //
  // It's shallowly cloned every time we move to the next page,
  // to create the illusion that nodes are continuing from page
  // to page.
  //
  // The transition can be customized by setting a Split rule,
  // which lets you add classes to the original and cloned element
  // to customize styling.

  const clonePath = (oldPath, applyRules) => {
    const newPath = [];

    const deepClone = (el) => {
      const clone = el.cloneNode(true); // deep clone, could be th > h3 > span;
      applyRules(el, clone);
      return clone;
    };

    for (let i = oldPath.length - 1; i >= 0; i -= 1) {
      const original = oldPath[i];
      const clone = original.cloneNode(false); // shallow
      const nextChild = oldPath[i + 1];
      clone.innerHTML = '';

      applyRules(original, clone, nextChild, deepClone);

      if (i < oldPath.length - 1) clone.appendChild(newPath[i + 1]);
      newPath[i] = clone;
    }

    return newPath;
  };

  // Polls every 10ms for image.naturalWidth
  // or an error event.
  //
  // Note: Doesn't ever reject, since missing images
  // shouldn't prevent layout from resolving

  const wait10 = () => new Promise((resolve) => {
    setTimeout(() => { resolve(); }, 10);
  });

  const ensureImageLoaded = async (image) => {
    const imgStart = performance.now();
    let failed = false;
    image.addEventListener('error', () => { failed = true; });
    image.src = image.src; // re-trigger error if already failed

    while (!image.naturalWidth && !failed) {
      await wait10();
    }

    return performance.now() - imgStart;
  };

  const preserveNumbering = (original, clone, nextChild) => {
    // restart numbering
    let prevStart = 1;
    if (original.hasAttribute('start')) {
      // the OL is also a continuation
      prevStart = parseInt(original.getAttribute('start'), 10);
    }
    if (nextChild && nextChild.tagName === 'LI') {
      // the first list item is a continuation
      prevStart -= 1;
    }
    const prevCount = original.children.length;
    const newStart = prevStart + prevCount;
    clone.setAttribute('start', newStart);
  };

  const preserveTableColumns = (original, clone, nextChild, deepClone) => {
    const columns = [...original.children];

    const currentIndex = columns.indexOf(nextChild);
    for (let i = 0; i < currentIndex; i += 1) {
      const clonedCol = deepClone(columns[i]);
      clone.appendChild(clonedCol);
    }
  };

  const noop = () => {};
  const always = () => true;
  const never = () => false;

  // flow content through FlowBoxes.
  // This function is not book-specific,
  // the caller is responsible for managing
  // and creating boxes.
  const flowIntoRegions = async (opts) => {
    // required options
    const content = opts.content;
    const createRegion = opts.createRegion;
    if (!content) throw Error('content not specified');
    if (!createRegion) throw Error('createRegion not specified');

    // optional
    const applySplit = opts.applySplit || noop;
    const canSplit = opts.canSplit || always;
    const beforeAdd = opts.beforeAdd || noop;
    const afterAdd = opts.afterAdd || noop;
    const didWaitFor = opts.didWaitFor || noop;
    const shouldTraverse = opts.shouldTraverse || never;

    // ____
    // Begin
    let currentRegion = createRegion();
    const hasOverflowed = () => currentRegion.hasOverflowed();
    const canSplitCurrent = () => canSplit(currentRegion.currentElement);
    const ignoreCurrentOverflow = () => ignoreOverflow(currentRegion.currentElement);

    const splitRules = (prev, clone, next, deepClone) => {
      if (prev.tagName === 'OL') preserveNumbering(prev, clone, next, deepClone);
      if (prev.tagName === 'TR') preserveTableColumns(prev, clone, next, deepClone);
      applySplit(prev, clone, next, deepClone);
    };

    const continueInNextRegion = () => {
      const oldBox = currentRegion;
      currentRegion = createRegion();

      const newPath = clonePath(oldBox.path, splitRules);
      currentRegion.setPath(newPath);
      return currentRegion;
    };

    const continuedParent = () => {
      continueInNextRegion();
      return currentRegion.currentElement;
    };

    const addTextWithoutChecks = (textNode, parent) => {
      parent.appendChild(textNode);
      if (!ignoreCurrentOverflow() && canSplitCurrent()) {
        currentRegion.suppressErrors = true;
        continueInNextRegion();
      }
    };

    const addSplittableTextNode = async (textNode) => {
      const el = currentRegion.currentElement;
      let hasAdded = await addTextNodeAcrossParents(textNode, el, continuedParent, hasOverflowed);
      if (!hasAdded && currentRegion.path.length > 1) {
        // retry 1
        tryInNextRegion(currentRegion, continueInNextRegion, canSplit);
        hasAdded = await addTextNodeAcrossParents(textNode, el, continuedParent, hasOverflowed);
      }
      if (!hasAdded) {
        // retry 2
        addTextWithoutChecks(textNode, currentRegion.currentElement);
      }
    };

    const addWholeTextNode = async (textNode) => {
      let hasAdded = await addTextNode(textNode, currentRegion.currentElement, hasOverflowed);
      if (!hasAdded && !ignoreCurrentOverflow()) {
        // retry 1
        tryInNextRegion(currentRegion, continueInNextRegion, canSplit);
        hasAdded = await addTextNode(textNode, currentRegion.currentElement, hasOverflowed);
      }
      if (!hasAdded) {
        // retry 2
        addTextWithoutChecks(textNode, currentRegion.currentElement);
      }
    };

    // No need to traverse every node if fifts AND
    // none of the contents could change size.
    // Images and custom rules could cause the size to change
    const canSkipTraversal = (element) => {
      const containsImage = element.querySelector('img');
      return !containsImage && !shouldTraverse(element);
    };

    let safeAddElementNode;

    // Adds an element node by clearing its childNodes, then inserting them
    // one by one recursively until they overflow the region
    const addElementNode = async (element) => {
      // Insert element
      currentRegion.currentElement.appendChild(element);
      currentRegion.path.push(element);

      if (canSkipTraversal(element)) {
        // console.log('maybe short circuit');
        if (!hasOverflowed()) {
          // console.log('did short circuit');
          return currentRegion.path.pop();
        }
      }

      // Clear element
      const childNodes = [...element.childNodes];
      element.innerHTML = '';

      // Overflows when empty
      if (hasOverflowed() && !ignoreCurrentOverflow() && canSplitCurrent()) {
        tryInNextRegion(currentRegion, continueInNextRegion, canSplit);
      }

      const shouldSplit = canSplit(element) && !ignoreOverflow(element);

      for (const child of childNodes) {
        if (isTextNode(child)) {
          await (shouldSplit ? addSplittableTextNode : addWholeTextNode)(child);
        } else if (isContentElement(child)) {
          await safeAddElementNode(child);
        }
      }
      return currentRegion.path.pop();
    };

    safeAddElementNode = async (element) => {
      // Ensure images are loaded before measuring
      if (isUnloadedImage(element)) {
        const waitTime = await ensureImageLoaded(element);
        didWaitFor(waitTime);
      }

      // Transforms before adding
      beforeAdd(element, continueInNextRegion);

      const addedElement = await addElementNode(element);

      // Transforms after adding
      afterAdd(addedElement, continueInNextRegion);
    };

    return safeAddElementNode(content);
  };

  exports.Region = Region;
  exports.flowIntoRegions = flowIntoRegions;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=regionize.umd.js.map
